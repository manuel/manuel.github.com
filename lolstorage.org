#+OPTIONS: toc:2 num:nil
#+TITLE: lolstorage: laughably good social networking and content sharing
#+AUTHOR: Manuel Simoni
#+EMAIL: msimoni@gmail.com

/lolstorage/'s approach to P2P [[http://twitter.com][/social networking/]] and /content
sharing/ is to layer a /Git/-style model with /commits/ and
/trees-of-hashes/ (for representing histories of filesystem trees) on
top of a /cryptographic capability/ system inspired by [[http://tahoe-lafs.org/~zooko/lafs.pdf][/Tahoe-LAFS/]]
(for integrity and privacy of content even when stored on untrusted
providers). It runs in the browser in JavaScript and uses local
storage APIs.  Application data is stored as filesystem trees.  An
example Twitter-like app may store a user's tweets in a YYYY/MM/DD
directory structure.

The user's /wallet/ contains write-caps for the user's /refs/ (which
are mutable pointers to commits), and is encrypted with a
passphrase. The user may generate a read-cap for a ref and share it
with other peers. This read-cap allows the peers to locally /clone/
the state of the shared ref, which is similar to /following/ in
Twitter. The local clone can be updated efficiently, using similar
methods as those used in Git fetching and pushing. There is no shared
state; only a single user ever writes to a ref. Presented to users is
a locally computed /overlay/ of content from local and cloned remote
refs (e.g. a Twitter-like timeline) that may index the content to
provide services like search and sorted and aggregated views.

The resulting system is simple, secure, and disruption-tolerant
vaporware.

* Cryptography

These constructions are based on [[http://tahoe-lafs.org/~zooko/lafs.pdf][/Tahoe-LAFS/]].  I more or less
directly copied them, hoping to keep all of their security features
intact.  They are simpler because files are not split into
Reed-Solomon encoded shares.

** Immutable objects

An immutable object is either a blob, a tree, or a commit.

Immutable objects are enrypted using a fresh encryption key and stored
under the hash of their ciphertext.

The verify cap for an immutable object contains the ciphertext hash,
allowing verification of stored content.

The read cap for an immutable object contains the verify cap and the
encryption key, allowing decryption of stored content.

[[[lolstorage/diagrams/immutable.png]]

*** To write an immutable object
 * Generate encryption key
 * Encrypt data using encryption key
 * Create verify cap by hashing ciphertext
 * Write ciphertext to store using verify cap as storage index
 * Return immutable read cap containing verify cap and encryption key

*** To read an immutable object given a read cap
 * Read ciphertext from store using verify cap as storage index
 * Check that ciphertext hashes to verify cap
 * Decrypt ciphertext using encryption key

*** Issues
 * Verify cap should probably be HMAC of ciphertext

** Mutable refs

A mutable ref "points to" the current commit: it contains a immutable
read cap for the commit.

For every mutable ref, a private-key pair is created.  The owner of
the ref has the private key, and thus can create new versions of the
ref.


[[[lolstorage/diagrams/mutable.png]]

*** To write a mutable ref
 * Create read key by hashing private key
 * Generate salt
 * Create encryption key by hashing salt and read key
 * Encrypt ref value using encryption key
 * Sign ciphertext and salt using private key
 * Create content from ciphertext, salt, signature, and public key
 * Create verify cap by hashing public key
 * Write content to store using verify cap as storage index
 * Return mutable read cap containing verify cap and read key

*** To read a mutable ref given a mutable read cap
 * Read ciphertext, salt, signature, and public key from store
   using verify cap as storage index
 * Check that public key hashes to verify cap
 * Verify signature of salt and ciphertext using public key
 * Create encryption key from salt and read key
 * Decrypt ciphertext using encryption key

* Storage and Capability URLs

Immutable objects and refs are stored on plain HTTPS servers.

The capability URL for an immutable read cap is:

https://server/path/to/verify-cap#encryption-key

The capability URL for a mutable read cap is:

https://server/path/to/verify-cap#read-key

It's important that the verify cap is the last element of the path, so
it can be mechanically extracted from the URL.

The encryption and read keys are present in the URLs after the sharp
sign fragment identifier, and thus are not sent to servers over HTTPS.

----------
